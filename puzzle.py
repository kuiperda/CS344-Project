#!/usr/bin/env python3

# run this file in its directory with './puzzle.py'

import random
import copy
from PIL import Image, ImageDraw
import os

# Notes:
# - unfinished currently includes both uncompleted paths and uncompleteable paths
# - still have to manually delete data from previous brute force attemtps when you reset class
# - make colored square puzzle next
# - do something to increase readability of image?
# - change the colors in the image

class WitnessPuzzle: 
    """ Generate puzzles from The Witness, and images of exhaustively solved puzzles.
        - Assume typical NxN with all vertices present, so NxN has (n+1)^2 vertices.
            Example of a basic 2x2: ['v', 'e', 'v', 'e', 'f'],
                                    ['e', ' ', 'e', ' ', 'e'],
                                    ['v', 'e', 'v', 'e', 'v'],
                                    ['e', ' ', 'e', ' ', 'e'],
                                    ['b', 'e', 'v', 'e', 'v'],
            Where the player starts at 'b' and arrives at 'f' by drawing a path
            along edges 'e' to vertices 'v' and the dimension refers to the ' ' spots.
        - Assume you always start at bottom left and end at top right with this class.
    """
    def __init__(self):
        self.grid = [] # stores puzzle generated by 'make...NxN' functions
        self.trail = [] # keeps track of places on the grid that have been visited
        self.moves = [] # keeps track of moves player made since the start
        self.imageNum = 0 # for use in image generation
        self.puzzleNum = 0 # for use in image generation

    # Basic puzzle, just draw a path to the end to solve it
    def makeBasicNxN(self, n):
        if n < 1: # puzzle dimension should not be lower than 1
            print("Problem: Make sure to use n >= 1 with makeBasicNxN()")
            return
        # start with a 1x1
        self.grid = [['v', 'e', 'v'], 
                    ['e', ' ', 'e'], 
                    ['v', 'e', 'v']]
        # extend the grid vertically if larger dimension
        for x in range(n - 1):
            self.grid.append(['e', ' ', 'e'])
            self.grid.append(['v', 'e', 'v'])
        # extend the grid horizontally the same amount
        for x in range(len(self.grid)):  
            for y in range(n - 1):
                if x % 2 == 0:
                    self.grid[x].extend(['e', 'v'])
                else:
                    self.grid[x].extend([' ', 'e'])
        # place the beginning and finish at bottom left and top right
        self.grid[0][-1] = 'f'
        self.grid[-1][0] = 'b'
        return self.grid
        
    # Simple puzzle, path has to cover all required vertices, marked by an X
    def makeDottedNxN(self, n, percent):
        if(percent < 0 or percent > 100): # percent should be between 0 and 100
            print("Problem: Make sure to use 0 < percent < 100 with makeBasicDottedNxN()")
            return
        # start with basic grid of same size, then replace some 'v' with 'X'
        self.makeBasicNxN(n)
        for x in range(len(self.grid)):
            if x % 2 == 0:
                for y in range(len(self.grid[x])):
                    if self.grid[x][y] == 'v' and random.randint(1,100) <= percent:
                        self.grid[x][y] = 'X'
        return self.grid

    # Simple puzzle, path has to separate squares of different colors
    #TODO: colored square puzzles
    # start with black and white on the ' ' spots...
    # change movement logs / trail to include edges you've been to
    # just travel along the edges from one square to another, if no path there
    #   then if different colors are connected, immediately break - not solved.

    # Manually try to solve a puzzle
    def playPuzzle(self):
        if(len(self.grid) < 3): # if grid is not even 1x1, they never made a puzzle.
            print("Problem: Make sure to create a puzzle before trying playPuzzle()")
            return

        retry = True
        while retry:
            
            # reset trail and moves for new attempt
            self.trail = [[len(self.grid) - 1, 0]]
            self.moves = []

            # loop moves until done
            state = "Unfinished"
            while(state == "Unfinished"):
                choice = input("Type w,a,s,d for up/left/down/right: ")
                if choice == 'w':
                    action = self.moveup()
                elif choice == 'a':
                    action = self.moveleft()
                elif choice == 's':
                    action = self.movedown()
                elif choice == 'd':
                    action = self.moveright()
                else:
                    print("Problem: Make sure to choose w/a/s/d in playPuzzle()")
                    return
                print(action)
                if action == "Solved" or action == "Finished" or action[0:7] == "Invalid":
                    state = "Ended"

            # retry or not after done
            retryChoice = input("Quit? (q) or retry: ")
            if retryChoice == 'q': retry = False

    # Movement
    def moveup(self):
        row, col = self.trail[-1] # position before moving
        if row > 0 and self.grid[row - 1][col] == 'e': # move if edge available
            if self.trail.count([row - 2, col]) > 0: # move if won't cross path
                return 'Invalid: Crossed Path!'
            # make the move and evaluate to see if you're done
            self.trail.append([row - 2, col])
            self.moves.append('up')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def movedown(self):
        row, col = self.trail[-1]
        if row < len(self.grid) - 1 and self.grid[row + 1][col] == 'e':
            if self.trail.count([row + 2, col]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row + 2, col])
            self.moves.append('down')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def moveleft(self):
        row, col = self.trail[-1]
        if col > 0 and self.grid[row][col-1] == 'e':
            if self.trail.count([row, col - 2]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row, col - 2])
            self.moves.append('left')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def moveright(self):
        row, col = self.trail[-1]
        if col < len(self.grid) - 1 and self.grid[row][col + 1] == 'e':
            if self.trail.count([row, col + 2]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row, col + 2])
            self.moves.append('right')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'

    # After moving, check if the end was reached and if the puzzle was solved
    def checkIfDone(self):
        row, col = self.trail[-1]

        # if position is at end, check additional rules
        if self.grid[row][col] == 'f':
            # check dots rule
            gotEveryDot = True
            for x in range(len(self.grid)):
                if gotEveryDot == False: break
                if x % 2 == 0:
                    for y in range(len(self.grid[x])):
                        if self.grid[x][y] == 'X':
                            if [x, y] not in self.trail:
                                gotEveryDot = False
                                break
            if gotEveryDot == True: # all rules followed
                return 'Solved'
            else:
                return 'Finished'
        else:
            return self.moves

    # Exhaustively solve a puzzle and record each attempted path as an image
    def startBruteForceSolution(self):
        if(len(self.grid) < 3): # make sure a puzzle to solve exists
            print("Problem: Make sure to create a puzzle before trying startBruteForceSolution()")
            return
        # reset trail and moves to beginning
        self.trail = [[len(self.grid) - 1, 0]]
        self.moves = []
        # apply recursive step to all available moves from current position
        self.bruteForceStep('up')
        self.bruteForceStep('left')
        self.bruteForceStep('down')
        self.bruteForceStep('right')
        
        self.puzzleNum += 1
        return 'Brute Force Done!'
        
    # Recursive function calls itself in each direction at each vertex.
    def bruteForceStep(self, direction):
        if direction == 'up':
            result = self.moveup()
        elif direction == 'left':
            result = self.moveleft() 
        elif direction == 'down':
            result = self.movedown()
        elif direction == 'right':
            result = self.moveright()

        if result[0:7] == 'Invalid':
            return

        # path was not invalid so make a grid image of this path 
        gridToSend = copy.deepcopy(self.grid)
        head = [len(gridToSend[0]) - 1, 0] # start at beginning, then inscribe moves
        for move in self.moves:
            if move == 'up':
                head[0] -= 1
                gridToSend[head[0]][head[1]] = 'u'
                head[0] -= 1
            elif move == 'left':
                head[1] -= 1
                gridToSend[head[0]][head[1]] = 'l'
                head[1] -= 1
            elif move == 'down':
                head[0] += 1
                gridToSend[head[0]][head[1]] = 'd'
                head[0] += 1
            elif move == 'right':
                head[1] += 1
                gridToSend[head[0]][head[1]] = 'r'
                head[1] += 1
            else:
                print("Error inscribing path in bruteForceStep()")

        if result == 'Solved':
            gridToSend[0][len(gridToSend) - 1] = 'S'
            self.writeGrid(gridToSend)
        elif result == 'Finished':
            gridToSend[0][len(gridToSend) - 1] = 'F'
            self.writeGrid(gridToSend)
        else:
            self.writeGrid(gridToSend)
            
            # if not done, apply recursive step in every direction again
            self.bruteForceStep('up')
            self.bruteForceStep('right')
            self.bruteForceStep('down')
            self.bruteForceStep('left')
            
        # when returning to parent step, get rid of this move in the list
        self.moves.pop()
        self.trail.pop()

    # Create the image and save it
    def writeGrid(self, grid):
    
        dim = len(grid[0]) # how many 'pixels' each representing vertex, edge, etc...
        pxSize = 100 # size of each 'pixel'
        w = dim * pxSize # width of image
        h = dim * pxSize # height of image

        # make the image
        img  = Image.new( mode = "RGB", size = (w, h) )
        draw = ImageDraw.Draw(img)
        
        for x in range(dim):
            for y in range(dim):

                # fill each pixel with color based on character on the grid
                char = grid[y][x]

                correspondingColor = {
                    'v': '#FFFF00', # vertices are yellow
                    'X': '#FFA500', # required vertices are orange
                    'e': '#EEE8AA', # untouched edges are palegoldenrod

                    ' ': '#808080', # spaces are gray
                    'W': '#FFFFFF', # white squares are white
                    'B': '#000000', # black squares are black

                    # all path directions are steelblue
                    'u': '#4682B4',
                    'd': '#4682B4',
                    'l': '#4682B4',
                    'r': '#4682B4',

                    'b': '#BDB76B', # begin is darkkhaki
                    'f': '#FFD700', # finish is gold
                    'S': '#FFD700', # Solved is gold
                    'F': '#FFD700' # Finished is gold
                }

                fillcolor = correspondingColor[char]
                
                draw.rectangle((0 + x * pxSize, 0 + y * pxSize, x * pxSize + w / dim, y * pxSize + h / dim), fill=fillcolor)

        # save the image
        imgfilename = './puzzle'+str(self.puzzleNum)+'/'
        if grid[0][-1] == 'S':
            imgfilename += 'solved/'
        elif grid[0][-1] == 'F':
            imgfilename += 'finished/'
        else:
            imgfilename += 'unfinished/'

        if not os.path.exists(imgfilename):
            os.makedirs(imgfilename)
        imgfilename += '/grid'+str(self.imageNum)+'.png'
            
        self.imageNum += 1
        
        img.save(imgfilename)

# Manual Testing
test = WitnessPuzzle()

test.makeDottedNxN(2, 50)
test.startBruteForceSolution()
