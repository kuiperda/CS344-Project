#!/usr/bin/env python3

# run this file in its directory with './puzzle.py'

import random
import copy
from PIL import Image, ImageDraw
import os
import shutil

# Notes:
# - consider image readability?
# - u/r/d/l seems unnecessary, just write path and it's apparent? - maybe

# for RL path similarity- maybe still use grid representation, and just ask how many u/r/d/l do they have in common?
# once you make all the grids, you have the arrays for the solved grids
# then for all of the unfinished paths, assign value- based on how good they are compared to solved path?

#ok - model should receive a grid/state and assign it a heuristic- model needs to be trained on a grid + heuristic. 
# I need to take grids and assign heuristics to them for that training data. 
# so figure out how to decide which paths are closer to being solved.

# so, for each unfinished grid, figure out how many solved/finished/stuck end states it could lead to, use that for number?

'''plan:
 name each grid using its path
 then have a separate function assign the heur. to unfinished states based on only solved states (does solved have this path? 
    how much left if so?)
 '''



# TODO: now think about the reinforcement learning side, maybe contact KCA with ideas?

class WitnessPuzzle: 
    """ Generate puzzles from The Witness, and images of exhaustively solved puzzles.
        - Assume typical NxN with all vertices present, so NxN has (n+1)^2 vertices.
            Example of a basic 2x2: ['v', 'e', 'v', 'e', 'f'],
                                    ['e', ' ', 'e', ' ', 'e'],
                                    ['v', 'e', 'v', 'e', 'v'],
                                    ['e', ' ', 'e', ' ', 'e'],
                                    ['b', 'e', 'v', 'e', 'v'],
            Where the player starts at 'b' and arrives at 'f' by drawing a path
            along edges 'e' to vertices 'v' and the dimension refers to the ' ' spots.
        - Assume you always start at bottom left and end at top right with this class.
    """
    def __init__(self):
        self.grid = [] # stores puzzle generated by 'make...NxN' functions
        self.trail = [] # keeps track of places on the grid that have been visited
        self.moves = [] # keeps track of moves player made since the start
        self.imageNum = 0 # for use in image generation
        self.puzzleNum = 0 # for use in image generation

        # clean up old data
        for x in range(len(os.listdir('.'))):
            dirToDel = './puzzle'+str(x)
            if os.path.exists(dirToDel):
                shutil.rmtree(dirToDel)

    # Basic puzzle, just draw a path to the end to solve it
    def makeBasicNxN(self, n):
        if n < 1: # puzzle dimension should not be lower than 1
            print("Problem: Make sure to use n >= 1 with makeBasicNxN()")
            return
        # start with a 1x1
        self.grid = [['v', 'e', 'v'], 
                    ['e', ' ', 'e'], 
                    ['v', 'e', 'v']]
        # extend the grid vertically if larger dimension
        for x in range(n - 1):
            self.grid.append(['e', ' ', 'e'])
            self.grid.append(['v', 'e', 'v'])
        # extend the grid horizontally the same amount
        for x in range(len(self.grid)):  
            for y in range(n - 1):
                if x % 2 == 0:
                    self.grid[x].extend(['e', 'v'])
                else:
                    self.grid[x].extend([' ', 'e'])
        # place the beginning and finish at bottom left and top right
        self.grid[0][-1] = 'f'
        self.grid[-1][0] = 'b'
        return self.grid
        
    # Simple puzzle, path has to cover all required vertices, marked by an X
    def makeDottedNxN(self, n, percent):
        if(percent < 0 or percent > 100): # percent should be between 0 and 100
            print("Problem: Make sure to use 0 < percent < 100 with makeBasicDottedNxN()")
            return
        # start with basic grid of same size, then replace some 'v' with 'X'
        self.makeBasicNxN(n)
        for x in range(len(self.grid)):
            if x % 2 == 0:
                for y in range(len(self.grid[x])):
                    if self.grid[x][y] == 'v' and random.randint(1,100) <= percent:
                        self.grid[x][y] = 'X'
        return self.grid

    # Simple puzzle, path has to separate squares of different colors
    def makeSquaresNxN(self, n, whitePercent, blackPercent):
        # make sure percents are reasonable
        whitePercent = abs(whitePercent)
        blackPercent = abs (blackPercent)
        if whitePercent + blackPercent < 0 or whitePercent + blackPercent > 100:
            print("Problem: white/black percents must add up to between 0 and 100 in makeSquaresNxN()")
            return
        self.makeBasicNxN(n)
        # add colored squares to grid
        for x in range(len(self.grid)):
            if x % 2 == 1:
                for y in range(len(self.grid[x])):
                    if self.grid[x][y] == ' ':
                        rand = random.randint(1, 100)
                        if rand <= whitePercent: self.grid[x][y] = 'W'
                        elif rand <= whitePercent + blackPercent: self.grid[x][y] = 'B'
        return self.grid

    # Medium puzzle, includes dots and squares - almost exactly a copy of makeSquaresNxN()
    def makeDottedSquaresNxN(self, n, dotPercent, whitePercent, blackPercent):
        # make sure percents are reasonable
        whitePercent = abs(whitePercent)
        blackPercent = abs (blackPercent)
        if whitePercent + blackPercent < 0 or whitePercent + blackPercent > 100:
            print("Problem: white/black percents must add up to between 0 and 100 in makeSquaresNxN()")
            return
        self.makeDottedNxN(n, dotPercent)
        # add colored squares to grid
        for x in range(len(self.grid)):
            if x % 2 == 1:
                for y in range(len(self.grid[x])):
                    if self.grid[x][y] == ' ':
                        rand = random.randint(1, 100)
                        if rand <= whitePercent: self.grid[x][y] = 'W'
                        elif rand <= whitePercent + blackPercent: self.grid[x][y] = 'B'
        return self.grid
    
    # Manually try to solve a puzzle
    def playPuzzle(self):
        if(len(self.grid) < 3): # if grid is not even 1x1, they never made a puzzle.
            print("Problem: Make sure to create a puzzle before trying playPuzzle()")
            return

        retry = True
        while retry:
            
            # reset trail and moves for new attempt
            self.trail = [[len(self.grid) - 1, 0]]
            self.moves = []

            # loop moves until done
            state = "Unfinished"
            while(state == "Unfinished"):
                choice = input("Type w,a,s,d for up/left/down/right: ")
                if choice == 'w':
                    action = self.moveup()
                elif choice == 'a':
                    action = self.moveleft()
                elif choice == 's':
                    action = self.movedown()
                elif choice == 'd':
                    action = self.moveright()
                else:
                    print("Problem: Make sure to choose w/a/s/d in playPuzzle()")
                    return
                print(action)
                if action == "Solved" or action == "Finished" or action[0:7] == "Invalid":
                    state = "Ended"

            # retry or not after done
            retryChoice = input("Quit? (q) else retry: ")
            if retryChoice == 'q': retry = False

    # Movement
    def moveup(self):
        row, col = self.trail[-1] # position before moving
        if row > 0 and self.grid[row - 1][col] == 'e': # move if edge available
            if self.trail.count([row - 2, col]) > 0: # move if won't cross path
                return 'Invalid: Crossed Path!'
            # make the move and evaluate to see if you're done
            self.trail.append([row - 1, col])
            self.trail.append([row - 2, col])
            self.moves.append('up')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def movedown(self):
        row, col = self.trail[-1]
        if row < len(self.grid) - 1 and self.grid[row + 1][col] == 'e':
            if self.trail.count([row + 2, col]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row + 1, col])
            self.trail.append([row + 2, col])
            self.moves.append('down')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def moveleft(self):
        row, col = self.trail[-1]
        if col > 0 and self.grid[row][col-1] == 'e':
            if self.trail.count([row, col - 2]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row, col - 1])
            self.trail.append([row, col - 2])
            self.moves.append('left')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'
    def moveright(self):
        row, col = self.trail[-1]
        if col < len(self.grid) - 1 and self.grid[row][col + 1] == 'e':
            if self.trail.count([row, col + 2]) > 0:
                return 'Invalid: Crossed Path!'
            self.trail.append([row, col + 1])
            self.trail.append([row, col + 2])
            self.moves.append('right')
            return self.checkIfDone()
        return 'Invalid: Out of Bounds!'

    # After moving, check if the end was reached and if the puzzle was solved
    def checkIfDone(self):
        row, col = self.trail[-1]

        # if position is at end, check additional rules
        if self.grid[row][col] == 'f':
            # check dots rule
            gotEveryDot = True
            for x in range(len(self.grid)):
                if not gotEveryDot: break
                if x % 2 == 0:
                    for y in range(len(self.grid[x])):
                        if self.grid[x][y] == 'X':
                            if [x, y] not in self.trail:
                                gotEveryDot = False
                                break

            # check squares rule
            squaresAreHappy = True
            remainingSquares = []
            # populate remainingSquares with all white and black spaces
            for x in range(len(self.grid)):
                for y in range(len(self.grid)):
                    if self.grid[x][y] == 'W' or self.grid[x][y] == 'B':
                        remainingSquares.append([x, y])
            # check adjacency
            while len(remainingSquares) > 0 and squaresAreHappy:
                startingSquare = remainingSquares.pop(0)
                adjacentSquares = [startingSquare]
                squaresToCheck = [startingSquare]
                # add adjacent squares 'recursively' but not actually using recusion
                currentCheckTrail = []
                while len(squaresToCheck) > 0:
                    currentSquare = squaresToCheck.pop(0)
                    # check edge in each direction
                    # up
                    if currentSquare[0] > 1: # don't go off the grid
                        upOne = [currentSquare[0] - 1, currentSquare[1]]
                        if upOne not in self.trail and upOne not in currentCheckTrail:
                            currentCheckTrail.append(upOne)
                            upTwo = [upOne[0] - 1, upOne[1]]
                            squaresToCheck.append(upTwo)
                            adjacentSquares.append(upTwo)
                    # left
                    if currentSquare[1] > 1: # don't go off the grid
                        leftOne = [currentSquare[0], currentSquare[1] - 1]
                        if leftOne not in self.trail and leftOne not in currentCheckTrail:
                            currentCheckTrail.append(leftOne)
                            leftTwo = [leftOne[0], leftOne[1] - 1]
                            squaresToCheck.append(leftTwo)
                            adjacentSquares.append(leftTwo)
                    # down
                    if currentSquare[0] < len(self.grid) - 2: # don't go off the grid
                        downOne = [currentSquare[0] + 1, currentSquare[1]]
                        if downOne not in self.trail and downOne not in currentCheckTrail:
                            currentCheckTrail.append(downOne)
                            downTwo = [downOne[0] + 1, downOne[1]]
                            squaresToCheck.append(downTwo)
                            adjacentSquares.append(downTwo)
                    # right
                    if currentSquare[1] < len(self.grid) - 2: # don't go off the grid
                        rightOne = [currentSquare[0], currentSquare[1] + 1]
                        if rightOne not in self.trail and rightOne not in currentCheckTrail:
                            currentCheckTrail.append(rightOne)
                            rightTwo = [rightOne[0], rightOne[1] - 1]
                            squaresToCheck.append(rightTwo)
                            adjacentSquares.append(rightTwo)
                # check if squares conflict
                convertedSquares = []
                for square in adjacentSquares:
                    convertedSquares.append(self.grid[square[0]][square[1]])
                if convertedSquares.count('W') > 0 and convertedSquares.count('B') > 0:
                    squaresAreHappy = False
                else:
                    for square in remainingSquares:
                        if square in adjacentSquares:
                            remainingSquares.remove(square) # remove squares we already checked

            if gotEveryDot and squaresAreHappy: # all rules followed
                return 'Solved'
            else:
                return 'Finished'
        else:
            return self.moves

    # Exhaustively solve a puzzle and record each attempted path as an image
    def startBruteForceSolution(self):
        if(len(self.grid) < 3): # make sure a puzzle to solve exists
            print("Problem: Make sure to create a puzzle before trying startBruteForceSolution()")
            return
        # reset trail and moves to beginning
        self.trail = [[len(self.grid) - 1, 0]]
        self.moves = []
        # apply recursive step to all available moves from current position
        self.bruteForceStep('up')
        self.bruteForceStep('left')
        self.bruteForceStep('down')
        self.bruteForceStep('right')
        
        self.puzzleNum += 1
        return 'Brute Force Done!'
        
    # Recursive function calls itself in each direction at each vertex.
    def bruteForceStep(self, direction):
        if direction == 'up':
            result = self.moveup()
        elif direction == 'left':
            result = self.moveleft() 
        elif direction == 'down':
            result = self.movedown()
        elif direction == 'right':
            result = self.moveright()

        if result[0:7] == 'Invalid':
            return 'Invalid'

        # path was not invalid so make a grid image of this path 
        gridToSend = copy.deepcopy(self.grid)
        head = [len(gridToSend[0]) - 1, 0] # start at beginning, then inscribe moves
        for move in self.moves:
            if move == 'up':
                head[0] -= 1
                gridToSend[head[0]][head[1]] = 'u'
                head[0] -= 1
            elif move == 'left':
                head[1] -= 1
                gridToSend[head[0]][head[1]] = 'l'
                head[1] -= 1
            elif move == 'down':
                head[0] += 1
                gridToSend[head[0]][head[1]] = 'd'
                head[0] += 1
            elif move == 'right':
                head[1] += 1
                gridToSend[head[0]][head[1]] = 'r'
                head[1] += 1
            else:
                print("Error inscribing path in bruteForceStep()")

        if result == 'Solved':
            gridToSend[0][len(gridToSend) - 1] = 'S'
            self.writeGrid(gridToSend, 'Solved')
        elif result == 'Finished':
            gridToSend[0][len(gridToSend) - 1] = 'F'
            self.writeGrid(gridToSend, 'Finished')
        else:
            # Not done; apply recursive step in every direction again
            upResult = self.bruteForceStep('up')
            rightResult = self.bruteForceStep('right')
            downResult = self.bruteForceStep('down')
            leftResult = self.bruteForceStep('left')

            # if all of these returned invalid, this path is Stuck
            if upResult == 'Invalid' and rightResult == 'Invalid' and downResult == 'Invalid' and leftResult == 'Invalid':
                self.writeGrid(gridToSend, 'Stuck')
            else:
                self.writeGrid(gridToSend, 'Unfinished')

        # when returning to parent step, get rid of this move in the list
        self.moves.pop()
        self.trail.pop()
        self.trail.pop()

    # Create the image and save it
    def writeGrid(self, grid, type):
    
        dim = len(grid[0]) # how many 'pixels' each representing vertex, edge, etc...
        pxSize = 10 # size of each 'pixel'
        w = dim * pxSize # width of image
        h = dim * pxSize # height of image

        # make the image
        img  = Image.new( mode = "RGB", size = (w, h) )
        draw = ImageDraw.Draw(img)
        
        for x in range(dim):
            for y in range(dim):

                # fill each pixel with color based on character on the grid
                char = grid[y][x]

                correspondingColor = {
                    'v': '#FFFF00', # vertices are yellow
                    'X': '#FFA500', # required vertices are orange
                    'e': '#EEE8AA', # untouched edges are palegoldenrod
                    ' ': '#808080', # spaces are gray

                    'W': '#FFFFFF', # white squares are white
                    'B': '#000000', # black squares are black

                    # all path directions are steelblue
                    'u': '#4682B4',
                    'd': '#4682B4',
                    'l': '#4682B4',
                    'r': '#4682B4',

                    'b': '#BDB76B', # begin is darkkhaki
                    'f': '#FFD700', # finish is gold
                    'S': '#FFD700', # Solved is gold
                    'F': '#FFD700' # Finished is gold
                }

                fillcolor = correspondingColor[char]
                
                draw.rectangle((0 + x * pxSize, 0 + y * pxSize, x * pxSize + w / dim, y * pxSize + h / dim), fill=fillcolor)

        # save the image
        imgfilename = './puzzle'+str(self.puzzleNum)+'/'
        if type == 'Solved':
            imgfilename += 'solved/'
        elif type == 'Finished':
            imgfilename += 'finished/'
        elif type == 'Stuck':
            imgfilename += 'stuck/'
        else:
            imgfilename += 'unfinished/'

        # name puzzles using string of their moves
        moveString = ""
        for move in self.moves:
            moveString += move[0]

        if not os.path.exists(imgfilename):
            os.makedirs(imgfilename)
        # imgfilename += '/grid'+str(self.imageNum)+'.png' # name puzzles with arbitrary number instead of moves
        imgfilename += moveString + '.png' # name puzzles with moves instead of arbitrary number
            
        self.imageNum += 1
        
        img.save(imgfilename)

    # take a bruteForced grid (puzzle0, for example) and assign heuristics to the unfinished paths
    def assignHeuristics(self, pathToPuzzle):
        if os.path.exists(pathToPuzzle):
            solvedPaths = []
            unfinishedPaths = []
            for grid in os.listdir(pathToPuzzle + '/solved'):
                solvedPaths.append(grid[:-4]) # remove the .png at the end
                os.rename(pathToPuzzle + '/solved/' + grid, pathToPuzzle + '/solved/' + '0' + grid)
            for grid in os.listdir(pathToPuzzle + '/finished'):
                os.rename(pathToPuzzle + '/finished/' + grid, pathToPuzzle + '/finished/' + '1000001' + grid)
            for grid in os.listdir(pathToPuzzle + '/stuck'):
                os.rename(pathToPuzzle + '/stuck/' + grid, pathToPuzzle + '/stuck/' + '1000002' + grid)
            for grid in os.listdir(pathToPuzzle + '/unfinished'):
                unfinishedPaths.append(grid[:-4]) # remove the .png at the end

            assignedPaths = []
            for unfinishedPath in unfinishedPaths: # TODO: make better heuristic, like how far away you are from the end
                pathFarness = 1000000
                for solvedPath in solvedPaths:
                    if solvedPath[:len(unfinishedPath)] == unfinishedPath:
                        pathFarness = min(len(solvedPath) - len(unfinishedPath),pathFarness) # NOTE: used min here, so chooses shortest path!!
                assignedPaths.append(str(pathFarness) + unfinishedPath)

            count = 0
            for grid in os.listdir(pathToPuzzle + '/unfinished'):
                os.rename(pathToPuzzle + '/unfinished/' + grid, pathToPuzzle + '/unfinished/' + assignedPaths[count]) # NOTE: no need to add .png?
                count += 1

    # make grid here manually - default is basic 3x3
    def useMyGrid(self):
        # self.grid = [
        #     ['v', 'e', 'v', 'e', 'v', 'e', 'f'],
        #     ['e', ' ', 'e', ' ', 'e', ' ', 'e'],
        #     ['v', 'e', 'v', 'e', 'v', 'e', 'v'],
        #     ['e', ' ', 'e', ' ', 'e', ' ', 'e'],
        #     ['v', 'e', 'v', 'e', 'v', 'e', 'v'],
        #     ['e', ' ', 'e', ' ', 'e', ' ', 'e'],
        #     ['b', 'e', 'v', 'e', 'v', 'e', 'v']
        # ]
        # self.grid = [
        #     ['v', 'e', 'X', 'e', 'X', 'e', 'f'],
        #     ['e', 'B', 'e', ' ', 'e', ' ', 'e'],
        #     ['v', 'e', 'v', 'e', 'v', 'e', 'v'],
        #     ['e', 'W', 'e', 'W', 'e', 'B', 'e'],
        #     ['v', 'e', 'X', 'e', 'v', 'e', 'v'],
        #     ['e', 'B', 'e', 'W', 'e', 'B', 'e'],
        #     ['b', 'e', 'v', 'e', 'v', 'e', 'X']
        # ]
        self.grid = [
            ['v', 'e', 'v', 'e', 'v', 'e', 'f'],
            ['e', ' ', 'e', 'B', 'e', 'W', 'e'],
            ['v', 'e', 'X', 'e', 'v', 'e', 'v'],
            ['e', 'B', 'e', ' ', 'e', 'B', 'e'],
            ['X', 'e', 'v', 'e', 'X', 'e', 'v'],
            ['e', 'B', 'e', ' ', 'e', ' ', 'e'],
            ['b', 'e', 'v', 'e', 'v', 'e', 'X']
        ]

# Manual Testing
''' Note: Save any data you want to keep before running this as 
    previous puzzle data will be deleted by the constructor!'''
test = WitnessPuzzle()

# test.makeDottedSquaresNxN(3, 25, 33, 33)
# test.startBruteForceSolution()

test.useMyGrid()
test.startBruteForceSolution()

test.assignHeuristics('./puzzle0')
